# JavaScript

> 是一种运行在客户端(浏览器)的编程语言，可以用来创建动态更新的内容，控制多媒体，制作图像动画等交互效果

## 基础知识

### `JavaScript`组成

- `ECMAScript`

  > 规定了`js`基础语法核https://pan.baidu.com/s/1xQvsClIoePxZ4G4WcoxTLQ?pwd=rkgc 心知识，比如：变量、分支语句、循环语句、对象等等

- `Web APIs`

  - `DOM`文档对象模型：定义了一套操作`HTML`文档的`API`
  - `BOM`浏览器对象模型，定义了一套操作浏览器窗口的API

![image-20240531122411007](images/image-20240531122411007.png)

### `JavaScript`书写位置

#### 内部`JavaScript`

直接写在html文件里面，用script标签包住

规范：script标签写在\</body>上面

注意事项：

- 将 \<script>放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载 HTML
- 如果先加载的JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。
- 因此，将JavaScript 代码放在 HTML页面的底部附近通常是最好的策略。

```html
<body>
    <scrpt>
    alert("警告")
    </scrpt>
</body>
```

#### 外部`JavaScript`

代码写在以`.js`结尾的文件里，通过script标签引入到html页面中

```js
// test.js
alert("警告")
```

```html
<body>
    <script src="./test.js"></script>
</body>
```

注意事项：

- script标签中间无需写代码，否则会被忽略
- 外部JavaScript会使代码更加有序，更易于复用，且没有了脚本的混合，HTML也会更加易读。

#### 行内`JavaScript`

代码写在标签内部

```html
<body>
    <button onclick="alert('警告')">
        警告
    </button>
</body>
```

### 注释

#### 单行注释

```js
// 单行注释内容
```

#### 块注释（多行注释）

```js
/*
多行注释内容
*/
```

### 结束符-`;`

> 实际开发中，可写可不写，浏览器（JavaScript引擎）可以自动推断语句的结束位置

作用：代表语句结束

```js
alert("警告");
```

### 输入输出语句

| 语法                           | 效果                       |
| ------------------------------ | -------------------------- |
| alert("页面弹出警示框")        | 输出语句，页面弹出警示框   |
| document.write('页面打印输出') | 输出语句，页面文档打印输出 |
| console.log("控制台打印输出")  | 输出语句，控制台输出       |
| prompt('请输入：')             | 输入语句，输入对话框       |

### 变量

> 计算机存储数据的“容器”

- 变量命名规则与规范
  - 规则
    - 不能使用关键字
    - 只能用下划线、字母、数字、$组成，且数字不能开头
    - 字母严格区分大小写
  - 规范
    - 起名要有意义
    - 遵守小驼峰命名法
      - 第一个单词首字母小写，后面每个单词首字母大写，如userName

- 声明变量

  > 要想使用变量，首先要创建变量（也称为声明变量或者定义变量），声明变量由两部分构成：声明关键字、变量名（标识）

  ```js
  // let即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语
  let num=10
  var age = 10 // 不推荐
  ```

  - var声明的变量没有块级作用域，let声明的变量有块级作用域

  - var声明的变量会具有变量提升，let不具备变量提升。

    变量提升：

    - 将该声明变量放在当前作用域的最前方
    - 提升时，只提升变量声明，不提升变量赋值

    ```js
    function fn(){
        a = 20
        var a = 10
    }
    // 等价于
    function fn(){
        var a
        a = 20
        a = 10
    }
    ```

  - 在同一作用域下，var可重复声明变量，let不可以

  - 不加声明关键字的变量默认是var声明，具有var声明的所有特点

- 更新变量（更换变量里面的值）

  ```js
  let num=10
  num = 12 // 更新变量num为12
  ```

- 同时声明多个变量

  语法：多个变量中间用逗号隔开

  ```js
  let age = 18, name = 'lili'
  ```
  
- 变量的访问原则

  在能够访问到的情况下先局部，局部没有再招上一级作用域，即就近原则


### 常量

> 是一个用于保存数据的容器，常量里面保存的值是不允许改变的

- 声明常量

  ```js
  const pi = 3.14
  ```

### 作用域（Scope)

> 变量或值在代码中可用性的范围，作用域的使用可以提高程序逻辑的局部性，增强程序的可靠性，减少命名冲突

#### 全局作用域

> 全局有效，作用于所有代码执行的环境（整个script标签内部或者一个独立的js文件）

#### 局部作用域

> 局部有效，只能在当前局部内部访问和修改

- 函数作用域

  > 作用于函数内部的代码函数

- 块级作用域

  > `{}`大括号内部

- 注意事项

  - 如果函数内部变量没有声明直接赋值，也当全局变量看，但强烈不推荐
  - 函数内部的形参可以看做是局部变量

#### 垃圾回收机制

> 垃圾回收机制(Garbage Collection)简称 GC，JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收

##### 内存的生命周期

`JS`环境中分配的内存，一般有如下生命周期:

- **内存分配**：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
- **内存使用**：即读写内存，也就是使用变量、函数等
- **内存回收**：使用完毕，由垃圾回收器自动回收不再使用的内存

说明：

- 全局变量一般不会回收（关闭页面回收）
- 一般情况下局部变量的值，不用了就会被自动回收掉

##### 内存泄漏

> 程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏

###### 闭包

> 概念：一个函数对周围状态的引用捆绑在一起，闭包让开发者可以从内部函数访问外部函数的作用域
>
> 简单理解：闭包 = 内层函数 + 外层函数的变量
>
> 闭包作用：实现数据的私有，避免全局污染，外层函数也可以访问里层函数变量

```js
function fun(){
    let a
    function fn(){
        a = 10
    }
    fn()
}
```

### 数据类型

#### 基本数据类型

| 类型      | 说明                               |
| --------- | ---------------------------------- |
| number    | 数字类型，用于运算操作，加减乘除等 |
| string    | 字符串类型                         |
| boolean   | 布尔类型                           |
| undefined | 未定义类型                         |
| null      | 空类型                             |

#### 引用数据类型

| 类型     | 说明                             |
| -------- | -------------------------------- |
| Array    | 数组，在单个变量名下存储多个数据 |
| function | 函数                             |
| Object   | 对象                             |

##### 数组

- 声明语法

  ```js
  let 数组名 = [数据1,数据2,...,数据n]
  ```

  - 数组是按顺序保存（有序），所以每个数据都有自己的编号
  - 编号从0开始，数据的编号经常称为索引或下标
  - 数组可以存储任意类型的数据

- 取值语法

  ```js
  数组名[下标]
  ```

- 常用属性

  | 属性          | 说明           |
  | ------------- | -------------- |
  | 数组名.length | 获取数组的长度 |

- 展开运算符-`...`

  > 将一个***数组或对象***进行展开，不会修改原数组/对象
  
  ```js
  const arr = [1,2,3]
  console.log(...arr) // 1 2 3
  const obj = {name:'111',age:16}
  console.log({...obj}) // {name:'111',age:16}
  ```
  
- 数组操作

  | 常用操作                                               | 说明                                           |
  | ------------------------------------------------------ | ---------------------------------------------- |
  | `数组名.push(data)`                                    | 将一个或多个元素添加到数组的末尾               |
  | `数组名.unshift(data)`                                 | 将一个或多个元素添加到数组的开头               |
  | `数组名.pop()`                                         | 从数组中删除最后一个元素，修改原数组           |
  | `数组名.shift()`                                       | 从数组中删除第一个元素，修改元素组             |
  | `数组名.splice(startIndex[,deleteCount,addItem1,...])` |                           可以从指定位置删除或增加数组元素，修改元数组。 |

  - 查询元素

    - 语法：数组名[下标]
    - 返回值：如果查询不到则返回`undefined`

  - 修改元素

    - 语法：数组名[下标] = 新值
    - 返回值：如果下标不存在，则是新增一个数组元素，并修改了数组长度（尽量避免）

  - 新增元素

    - `数组名.push(data)`
      - 作用：将一个或多个元素添加到数组的末尾
      - 返回值：该数组的新长度，会修改原数组
    - `数组名.unshift(data)`
      - 作用：将一个或多个元素添加到数组的开头
      - 返回值：该数组的新长度，会修改原数组

  - 删除元素

    - `数组名.pop()`
      - 作用：从数组中删除最后一个元素，修改原数组
      - 返回值：该元素的值
    - `数组名.shift()`
      - 作用：从数组中删除第一个元素，修改元素组
      - 返回值：该元素的值

##### 函数

> 是可以被重复执行的代码块，可以把具有相同或相似逻辑的代码“包裹”起来，有利于代码复用

- 函数的参数

  > 形参：声明函数时小括号里的叫形参（形式上的参数）
  >
  > 实参：调用函数时小括号里的叫实参（实际上的参数）
  >
  > 执行过程：调用时会把实参的数据传递给形参，从而提供函数内部使用
  >
  > 在JavaScript中实参的个数和形参的个数可以不一致
  >
  > - 如果形参过多会自动填上undefined
  > - 如果实参过多，那么多余的实参会被忽略
  >
  > 默认参数：可以给形参设置默认值
  >
  > - 这个默认值只会在缺少实参传递或者实参是`undefined`才会被执行

  - `arguments`对象

    > arguments 是函数内部内置的对象(伪数组)，它包含了调用函数时传入的所有实参

    ```js
    function fn(){
        console.log(arguments) // 伪数组：[1,2,3]
    }
    fn(1,2,3)
    ```

    - 箭头函数不支持`arguments`

  - 剩余参数

    > 允许我们将一个不定数量的参数表示为一个数组
    >
    > 简单理解：用于获取多余的实参，并形成一个真数组

    ```js
    function fn(...arr){
        console.log(arr) // 数组：[1,2,3]
    }
    fn(1,2,3)
    ```

    - 剩余参数只能写到参数的最后面
    - 箭头函数可以使用剩余参数
    - 可以用于解构赋值中

- 函数的返回值-`return`

  > 把处理结果返回给调用者

  - `return`会立即结束当前函数，所以后面代码不会被执行
  - 在`return`关键字和被返回的表达式之间不允许使用换行符，或者内部执行相当于会自动补充分号
  - 函数可以没有`return`，这种情况函数默认的返回值为`undefined`
  - 只能返回一个值

###### 具名函数

> 带有名字的函数

- 声明函数

  ```js
  function 函数名([形参列表]){
      函数体
      [return result]
  }
  ```

  - 函数名命名跟变量一致

  - 函数默认返回`undefined`

  - 具有函数提升的特点

    函数提升：会把函数声明提升到当前作用域的最前面

    ```js
    若干代码
    function fn(){
        
    }
    fn()
    // 等价于
    function fn(){
        
    }
    若干代码
    fn()
    ```

- 调用函数

  ```js
  函数名([实参列表])
  ```

  - 定义一个函数并不会自动执行它，需要调用函数
  - 函数可以多次调用，每次调用都会重新执行函数体里面的代码
  - 可以在声明前后调用

###### 匿名函数

> 没有名字的函数

- 函数表达式

  > 将匿名函数赋值给一个变量，并且通过变量名称进行调用

  ```js
  let 变量名 = function([形参列表]){}
  // 调用
  变量名([实参列表])
  ```

  - 只能在函数表达式之后调用【不存在函数提升】

- 立即执行函数

  > 可以避免全局变量之间的污染

  ```js
  // 方式1
  (function(形参列表){
      函数体
  })([实参列表]);
  // 方式2
  (function(形参列表){
      函数体
  }([实参列表]));
  ```

  - 立即执行函数在执行前后都要加`;`

###### 箭头函数

> 箭头函数更适用于那些本来需要匿名函数的地方，写法更简单

- 语法

  ```js
  let/const 函数名 = ([函数参数列表])=>{函数体}
  ```

  - 当箭头函数只有一个参数时，可以省略参数的小括号，其余个数不能省略(没有参数也需要写小括号)
  - 当箭头函数的函数体只有一句代码 可以省略函数体大括号，这句代码就是返回值(可以不用写return)
  - 省略函数体大括号时，如果返回的是个带花括号的对象，则需要把对象用小括号包裹
  - 箭头函数里面没有arguments，但是有剩余参数

  

##### 对象

> JavaScript里的一种数据类型（引用数据类型）,也是用于存储数据的

- 对象的组成

  - 属性
    - 事物的描述信息称为属性
    - 如姓名、身高、年龄等，一般是名词
  - 方法
    - 事物的行为性称为方法
    - 如跑步、唱歌等，一般是动词

- 对象的使用

  - 属性的使用

    1. 定义对象属性

       > 属性都是成对出现的，包括属性名和属性值

       ```js
       let 变量名={
           属性名1:属性值1,
           ...
       }
       ```

       - 属性名和属性值之间使用英文`:`分隔

       - 多个属性名和属性值之间使用英文`,`分隔，属性是无序的

       - 属性就是依附在对象上的变量（对象外是变量，对象内是属性)

       - 属性名和属性值变量名相同的时候可以简写

         ```js
         let uname = 'lili'
         let obj = {
             uname,
             arg:18,
         }
         ```

         

    2. 访问对象属性

       ```js
       对象名.属性名
       ```

  - 方法的使用

    1. 定义对象方法

       > 方法是成对出现的，包括方法名和匿名函数

       ```js
       let 变量名={
           方法名1:匿名函数1,
           ...
       }
       ```

       - 方法名和匿名函数之间使用英文`:`分隔
    
       - 多个方法之间使用英文`,`分隔，方法是无序的

       - 方法是依附在对象中的函数（对象外是函数，对象内是方法）

       - 方法可以写成函数的形式
    
         ```js
         let obj = {
             run([形参列表]){
                 方法体
             }
         }
         ```
    
    2. 调用对象方法
    
       ```js
       对象名.方法([实参列表])
       ```

- 操作对象

  | 操作                                          | 说明            |
  | --------------------------------------------- | --------------- |
  | 对象名.属性名/对象名.方法名                   | 查找属性或方法  |
  | 对象名.属性名 = 新值/对象名.方法名=匿名函数   | 修改属性值/方法 |
  | 对象名.新属性名=新值/对象名.新方法名=匿名函数 | 新增属性/方法   |
  | delete 对象名.属性名/delete 对象名.方法名     | 删除属性/方法   |

  - 对于多词属性比如中横线【pig-name】分割的属性`.`操作就无法使用了需要采用`对象名['属性名']`（单双引号都可以）方式

### 日期对象-`Date`

- 实例化

  ```js
  new Date(['日期'])
  // 获取当前时间
  new Date()
  // 获取指定时间
  new Date('日期')
  ```

- 常用方法

  | 方法                 | 作用                                     | 说明                 |
  | -------------------- | ---------------------------------------- | -------------------- |
  | getFullYear()        | 获取年份                                 | 获取四位年份         |
  | getMonth()           | 获取月份                                 | 取值为0-11           |
  | getDate()            | 获取月份中的每一天                       | 不同月份取值也不相同 |
  | getDay()             | 获取星期                                 | 取值为0-6，0表示周日 |
  | getHours()           | 获取小时                                 | 取值为0-23           |
  | getMinutes()         | 获取分钟                                 | 取值为0-59           |
  | getSeconds()         | 获取秒                                   | 取值为0-59           |
  | toLocaleString()     | 返回该日期对象的字符串（包含日期和时间） | 2011/11/11 11:11:11  |
  | toLocaleDateString() | 返回日期对象日期部分的字符串             | 2011/11/11           |
  | toLocaleTimeString() | 返回日期对象的时间部分                   | 11:11:11             |

#### 时间戳

> 是指1970年01月01日00时00分00秒起至现在的总毫秒数(数字型)，它是一种特殊的计量时间的方式

- 获取时间戳

  ```js
  // 方式1
  new Date().getTime()
  // 方式2
  Date.now()
  // 方式3
  +new Date()
  ```

### 运算符

> 算术运算符、比较运算符、逻辑运算符、自增/自减运算符、赋值运算符

- 算术运算符

  > 也叫数学运算符，主要包括加`+`、减`-`、乘`*`、除`/`、取余（取模）`%`等

- 赋值运算符

  | 赋值运算符 | 说明              |
  | ---------- | ----------------- |
  | +=         | x+=1等价于x=x+1   |
  | -=         | x-=1等价于x=x-1   |
  | *=         | x\*=1等价于x=x\*1 |
  | /=         | x/=1等价于x=x/1   |
  | %=         | x%=1等价于x=x%1   |

- 自增/自减运算符

  > 自增：++
  >
  > 自减：--

  注意：

  - 只有变量能够使用自增和自减运算符
  - ++、--可以在变量前面，也可以在变量后面，比如x++,++x
  - 在运算或输出中前置自增/自减是先运算或输出后自增或自减

- 比较运算符

  > 比较两个数据大小、是否相等，根据比较结果返回一个布尔值(true/false)

  | 比较运算符 | 说明                       |
  | ---------- | -------------------------- |
  | >          | 左边是否大于右边           |
  | <          | 左边是否小于右边           |
  | >=         | 左边是否大于或等于右边     |
  | <=         | 左边是否或等于小于右边     |
  | ===        | 左右两边是否类型和值都相等 |
  | ==         | 左右两边值是否相等         |
  | !=         | 左右两边值是否不相等       |
  | !==        | 左右两边是否不全等         |

- 逻辑运算符

  > 可以把多个布尔值放到一起运算，最终返回一个布尔值

  | 符号 | 名称   | 特点           |
  | ---- | ------ | -------------- |
  | &&   | 逻辑与 | 一假则假       |
  | \|\| | 逻辑或 | 一真则真       |
  | !    | 逻辑非 | 真变假，假变真 |
  
  - 逻辑中断
  
    > 存在于逻辑运算符`&&`和`||`，左边如果满足一定条件会中断代码执行，也称逻辑短路
  
    ```js
    false && 其他判断 // 左边false则中断，如果左边为true则返回右边代码的值
    true||其他判断//左边true则中断，如果左边为false则返回右边代码的值
    ```
  
    ```js
    0 && 20 // 0
    10 && 20 //20
    0 || 20 // 20
    10 || 20 //0
    ```
  
    

#### 运算符优先级

| 优先级 | 顺序             |
| ------ | ---------------- |
| 1      | ()               |
| 2      | ++、--、!        |
| 3      | 先*、/、%后+、-  |
| 4      | >、>=、<、<=     |
| 5      | ==、!=、===、!== |
| 6      | 先&&后\|\|       |
| 7      | =                |

### 类型转换

> 把一种类型转换成另一种类型

#### 显示转换

##### 转换为数字型

- `Number(data)`
  - 转换成功返回一个数字类型
  - 转换失败则返回NaN
- `parseInt(data)`
  - 只保留整数
  - 如果数字开头的字符串，只保留整数数字
- `parseFloat(data)`
  - 可以保留小数
  - 如果数字开头的字符串，可以保留小数

注意：

- 布尔型转换为数字：true为1，false为0
- null转换为数字0
- undefined为NaN

##### 转换为字符型

- `String(data)`
  - 返回字符串类型
- `变量.toSring(进制)`
  - 可以有进制转换

##### 转换为布尔值

- `Boolean(data)`
  - 返回true或false
  - 如果值为false、0、null、undefined、NaN、空串则返回false，其余返回true

#### 隐式转换

> 某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换

##### 转换为数字型

- 算术运算符：`-`、`*`、`/`、`%`
- 比较运算符:`>`、`==`等
- `+`号作为正号可以把字符串转换成数字型，例如`+'10'`

##### 转换为字符串型

- `+`加号字符串拼接

##### 转换为布尔值

- `!`逻辑非

### 表达式

> 可以被求值的代码，并将其计算出一个结果

```js
3+4
num++
```

### 语句

> 一段可以执行的代码，是一个行为，例如分支语句和循环语句

#### 程序三大流程控制语句

##### 顺序结构

> 代码从上往下按顺序执行

##### 分支结构

> 根据条件判定真假来选择执行代码

- 单分支语句（if语句）

  - 语法

    ```js
    if (条件){
        满足条件要执行的代码
    }
    ```

    - 小括号内的条件结果时布尔值，为true时，进入大括号里执行代码；为false，则不执行大括号里面的代码
    - 小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()
    - 如果大括号只有一个语句，大括号可以省略

- 双分支语句（if...else语句）

  - 语法

    ```js
    if (条件){
        满足条件要执行的代码
    }else{
        不满足条件要执行的代码
    }
    ```

- 多分支语句（if...else if...else语句)

  - 语法

    ```js
    if (条件1){
        代码1：满足条件1要执行的代码
    }else if(条件2){
        代码2：满足条件2要执行的代码
    }else if(条件3){
        代码3：满足条件3要执行的代码
    }else{
        代码n：全部不满足条件要执行的代码
    }
    ```

    - 先判断条件1，若满足条件1就执行代码1，其他不执行
    - 若不满足条件1则向下判断条件2，满足条件2执行代码2，其他不执行
    - 若依然不满足继续往下判断，以此类推
    - 若以上条件都不满足，执行else里的代码n

- 分支语句（switch语句）

  > 适合于有多个条件的时候，也属于分支语句，大部分情况下和if多分支语句功能相同

  - 语法

    ```js
    switch(表达式){
        case 值1：
            代码1
            break
        case 值2：
            代码2
            break
            ...
        default:
            代码n
    }
    ```

    - 找到跟小括号里数据全等的case值，并执行里面对应的代码
    - 若没有全等的则执行default里的代码
    - switch语句一般用于等值判断，if适合区间判断
    - switch语句一般需要配合break关键字使用，没有break会造成case穿透【不理睬判断按顺序往下执行，直到遇到break语句或者执行switch代码块完毕】

- 三元运算符

  > 一些简单的双分支，可以使用 三元运算符(三元表达式)，写起来比if else双分支 更简单

  - 语法

    ```js
    条件?表达式1:表达式2
    ```

    - 如果条件为真，则执行表达式1，否则执行表达式2

##### 循环结构

> 某段代码被重复执行

- while循环

  - 语法

    ```js
    while(循环条件){
        循环体
    }
    ```

    - 满足小括号里的条件为true才会进入循环体执行代码
    - while大括号里代码执行完毕后不会跳出，而是继续回到小括号里判断条件是否满足，若是满足又执行大括号里的代码，然后再回到小括号判断条件，直到括号内条件不满足即跳出。

- for循环

  - 语法

    ```js
    for(初始值;循环条件;变量计数){
        满足条件执行的循环体
    }
    ```

    - 执行过程：初始值->循环条件->满足则执行循环体再执行变量计数，不满足则退出循环

- 中止循环

  - `break`中止整个循环，一般用于结果已经得到，后续的循环不需要的时候可以使用（提高效率）
  - `continue`中止本次循环，一般用于排除或者跳过某一个选项的时候

- 无限循环

  - `while(true)`来构建”无限循环
  - `for(;;)`来构建”无限循环

### Chrome断点调试

1. 按`F12`打开开发者工具
2. 颠倒源代码一栏（sources)
3. 选择代码文件
4. 添加断点：在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来


## `Web APIs`

### `DOM`

> DOM(Document Object Model——文档对象模型)，DOM用来操作网页文档，开发网页特效和实现用户交互，DOM的核心思想就是把网页内容当作对象来处理，通过对象的属性和方法对网页内容操作，比如DOM会把标签解析成DOM对象，修改这个对象的属性会自动修改到标签身上，从而可以修改标签的结构、样式或者内容

- `document`对象

  - 是DOM里提供的一个对象，是DOM顶级对象
  - 作为网页内容的入口
  - 它提供的属性和方法都是用来访问和操作网页内容的

- 获取DOM元素

  1. CSS选择器来获取DOM元素

     ```js
     document.querySelector('css选择器')// 返回匹配到的第一个元素，如果没有匹配到返回null
     document.querySelectorAll('css选择器')// 返回NodeList伪数组（有索引、长度但没有方法）
     ```

  2. 其他获取DOM元素

     ```js
     document.getElementById('id属性名')// 
     document.getElementsByClassName('class属性名')
     document.getElementsByTagName('标签名')
     document.getElementsByName('name属性名')
     ```

- 操作元素内容属性

  | 属性           | 说明       |
  | -------------- | ---------- |
  | 元素.innerText | 不解析标签 |
  | 元素.innerHTML | 解析标签   |

- 操作元素样式属性

  - 通过style属性操作元素样式

    ```js
    元素.style.样式属性 = 值
    ```

    - 修改样式通过style属性引出
    - 如果属性有`-`连接符，需要转换为小驼峰命名法

  - 通过类名（calssName)操作样式

    > 如果修改的样式比较多，直接通过style属性比较繁琐，我梦可以借助于css类名的形式

    ```js
    元素对象.className = 类名
    ```

    - 由于calss是关键字，所以使用className代替
    - className是使用新值换旧值，如果需要添加一个类，需要保留之前的类名

  - 通过classList操作元素样式

    > 可以追加和删除类名

    ```js
    元素对象.classList.add('类名') // 新增一个类名
    元素对象.classList.remove('类名') // 移除一个类名
    元素对象.classList.toggle('类名') // 切换类名
    元素对象.classList.contains('类名') // 是否存在某个类名
    ```

#### `DOM`节点

> DOM树：DOM 将 HTML文档以树状结构直观的表现出来，我们称之为 DOM 树 或者 节点树
>
> 节点(Node)：是DOM树(节点树)中的单个点。包括文档本身、元素、文本、属性以及注释都属于是节点。

##### 查找节点

- 父节点查找

  ```js
  子元素.parentNode// 返回最近一级的父节点对象，找不到返回null
  ```

- 子节点查找

  ```js
  节点对象.children // 返回的是一个伪数组
  ```

- 兄弟关系查找节点

  ```js
  节点对象.nextElementSibling // 获取下一个兄弟
  节点对象.previousElementSibling // 获取上一个兄弟
  ```

##### 增加节点

> 先创建再追加

1. 创建节点

   ```js
   document.createElement('标签名')
   ```

2. 追加节点

   ```js
   元素对象.append() // 父元素的最后一个子节点后插入
   元素对象.prepend() // 父元素第一个子节点之前插入
   ```

##### 删除节点

```js
元素对象.remove() // 把元素对象从它所属的DOM树中删除
```

#### 自定义属性

> 在html5中推出来的专门的`data-`自定义属性
>
> - 在标签上一律以`data-`开头
> - 在DOM对象上一律以`dataset`对象方式获取

#### 定时器

- 间隔函数

  - 开启定时器

    ```js
    setInterval(函数,间隔时间)
    ```

    - 作用：每隔一段时间调用这个函数
    - 间隔时间单位是毫秒
    - 定时器返回的是一个id数字

  - 关闭定时器

    ```js
    let 变量名 = setInterval(函数,间隔时间)
    clearInterval(变量名)
    ```
  
- 延迟函数

  > JavaScript 内置的一个用来让代码延迟执行的函数，叫setTimeout

  - 语法

    - 设置延迟

      ```js
      setTimeout(回调函数，等待的毫秒数)
      ```

      - `setTimeout`仅仅只执行一次，所以可以理解为把一段代码延迟执行
      - 延时函数需要等待，所以后面的代码先执行
      - 返回一个正整数，表示定时器的编号

    - 清除延迟

      ```js
      let 变量名 = setTImeout(回调函数，等待的毫秒数)
      clearTimeout(timer)
      ```

#### 事件

> 事件是程序在运行的时候，发生的特定动作或者特定的事情，比如点击按钮等

##### 事件监听

> 也称为事件注册、事件绑定

- 语法

  ```js
  // 方式1
  事件源.addEventListener('事件类型',事件处理函数,[捕获true或者冒泡阶段false])
  // 方式2
  事件源.on事件类型=匿名函数
  ```

  - 事件发生后，想要执行的代码写到事件处理函数里面
  - 当触发指定的事件时，则事件处理函数就会被执行
  - 事件监听是将事件处理函数注册到元素对象身上
  - 方式2同名事件会被覆盖，方式1则不会且拥有更多事件特性
  - 方式2只有冒泡阶段没有捕获阶段，方式1都有

- 三要素

  - 事件源：哪个元素上触发
  - 事件类型：什么情况下触发
  - 事件处理函数：触发什么样的行为

##### 移除事件监听

> 也称为解绑事件

- `addEventListener`方式注册必须使用`removeEventListener(事件类型,事件处理函数,[捕获true或者冒泡阶段false])`

  - `addEventListener`中使用的事件处理函数不能是匿名函数，否则无法解绑

  ```js
  function 函数名([形参列表]){
      事件处理
  }
  addEventListener(事件类型1,函数名)
  removeEventListener(事件类型1,函数名)
  ```

- `on`事件方式，直接使用`null`覆盖就可以实现事件的解绑

  ```js
  事件源.on事件类型 = null
  ```

##### 回调函数

> 当一个函数当作参数来传递给另外一个函数的时候，这个函数就是回调函数（回头调用的函数）

##### 事件类型

###### 鼠标事件

| 事件类型   | 说明                     |
| ---------- | ------------------------ |
| click      | 鼠标点击事件             |
| mouseenter | 鼠标经过事件，无事件冒泡 |
| mouseleave | 鼠标离开，无事件冒泡     |
| mouseover  | 鼠标经过事件，有事件冒泡 |
| mouseout   | 鼠标离开，有事件冒泡     |

###### 焦点事件

| 事件类型 | 说明     |
| -------- | -------- |
| focus    | 获取焦点 |
| blur     | 失去焦点 |

###### 文本事件

| 事件类型 | 说明                            |
| -------- | ------------------------------- |
| input    | 输入框的value值发生改变就会触发 |

###### 键盘事件

| 事件类型 | 说明           |
| -------- | -------------- |
| keydown  | 键盘按下时触发 |
| keyup    | 键盘弹起时触发 |

##### 事件对象

> 这个对象里有事件触发时的相关信息，包含属性和方法

- 语法

  - 注册事件中，回调函数的第一个参数就是事件对象
  - 一般命名为`event`、`e`

- 常见属性

  | 属性名   | 类型    | 说明                               |
  | -------- | ------- | ---------------------------------- |
  | altKey   | boolean | 事件发生时是否按下alt键            |
  | ctrlkey  | boolean | 事件发生时是否按下ctrl键           |
  | shiftKey | boolean | 事件发生时是否按下shift键          |
  | offsetX  | number  | 事件发生时鼠标相对于事件源的x坐标  |
  | offsetY  | number  | 事件发生时鼠标相对于事件源的y坐标  |
  | target   | object  | 事件源对象                         |
  | pageX    | number  | 事件发生时鼠标相对于网页的x坐标    |
  | pageY    | number  | 事件发生时鼠标相对于网页的y坐标    |
  | clientX  | number  | 事件发生时鼠标相对于视口的x坐标    |
  | clientY  | number  | 事件发生时鼠标相对于视口的y坐标    |
  | key      | string  | 键盘相关事件包含该属性，指按下的键 |

##### 事件流

> 事件流指的是事件完整执行过程中的流动路径，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段

###### 事件捕获

> 当一个元素的事件被触发时，会从DOM的根元素开始一次调用**同名事件**（从父到当前事件源）

```html
<div class="father">
    <div class="son"></div>
</div>
```

```css
.father{
    width: 300px;
    height: 300px;
    background-color: yellow;
    overflow: hidden;
}
.son{
    width: 100px;
    height: 100px;
    background-color: blue;
    margin:50% auto;
    transform: translateY(-50%);
}
```

```js
let father = document.querySelector('.father')
father.addEventListener('click',function(){
    alert('父盒子事件触发了')
},true)
let son = document.querySelector('.son')
son.addEventListener('click',function(){
    alert("子盒子事件触发了")
},true)
```

###### 事件冒泡

> 当一个元素的事件被触发时，**同样的事件**将会在该元素的所有祖先元素中依次被触发（从当前事件源到父）。这以过程称为事件冒泡。

```html
<div class="father">
    <div class="son"></div>
</div>
```

```css
.father{
    width: 300px;
    height: 300px;
    background-color: yellow;
    overflow: hidden;
}
.son{
    width: 100px;
    height: 100px;
    background-color: blue;
    margin:50% auto;
    transform: translateY(-50%);
}
```

```js
let father = document.querySelector('.father')
father.addEventListener('click',function(){
    alert('父盒子事件触发了')
})
let son = document.querySelector('.son')
son.addEventListener('click',function(){
    alert("子盒子事件触发了")
})
```

###### 阻止冒泡

- 语法

  ```js
  事件对象.stopPropagation()
  ```

  - 词方法可以阻断事件流动传播，不管在冒泡阶段有效，捕获阶段也有效

##### 事件委托

> 事件委托（Event Delegation)：是JavaScript中注册事件的常用技巧，也称为事件委派、事件处理。

- 原本需要注册在子元素的事件委托给父级元素，让父级元素担当事件监听的职务
- 可以减少注册次数，提高程序性能

```html
<div class="father">
    <div class="son"></div>
</div>
```

```css
.father{
    width: 300px;
    height: 300px;
    background-color: yellow;
    overflow: hidden;
}
.son{
    width: 100px;
    height: 100px;
    background-color: blue;
    margin:50% auto;
    transform: translateY(-50%);
}
```

```js
let father = document.querySelector('.father')
father.addEventListener('click',function(e){
    console.log('点击事件触发了，触发的事件源是：')
    console.log(e.target)
})
```

##### 阻止默认行为

> 阻止元素发生默认的行为，例如当点击提交按钮时阻止对表单的提交，阻止链接的跳转等等

- 语法

  ```js
  事件对象.preventDefault()
  ```

- 示例

  ```html
  <a href="https://www.baidu.com">百度一下</a>
  <form action="https://www.baidu.com">
      <button>提交</button>
  </form>
  ```

  ```js
  let form = document.querySelector('form')
  let a = document.querySelector('a')
  a.addEventListener('click',function(e){
      e.preventDefault()
  })
  form.addEventListener('submit',function(e){
      e.preventDefault()
  })
  ```

##### 页面加载事件

> 加载外部资源（如图片、外联css和JavaScript等）加载完毕时触发的事件

| 事件               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| `load`             | 监听页面所有资源加载完毕【给window添加】                     |
| `DOMContentLoaded` | 初始HTML文档完全被加载和解析完成后触发，无需等待样式表、图像等完全加载【一般给document添加】 |

##### 页面滚动事件-`scroll`

> 滚动条滚动的时候持续触发的事件

| 事件常用属性 | 说明             |
| ------------ | ---------------- |
| scrollLeft   | 获取被卷去的左侧 |
| scrollTop    | 获取被卷去的头侧 |

![image-20240530151546854](images/image-20240530151546854.png)

```js
let xtx_elevator = document.querySelector('.xtx-elevator')
window.addEventListener('scroll',function(e){
    if(document.documentElement.scrollTop >= 300){
        xtx_elevator.style.opacity=1
    }else{
        xtx_elevator.style.opacity=0
    }
})
```

##### 页面尺寸事件-`resize`

- 获取宽高-`clientWidth/clientHeight`

  获取元素的可见部分宽高（不包含border，margin，滚动条等）

  `document.documentElement.clientWidth`

- 获取宽高-`offsetWidth/offsetHeight`

  > 获取元素自身的宽高包含width、height、border、padding，返回的是数字，并且是只读属性

- 获取元素距离自己定位父级元素的左`offsetLeft`、上`offsetTop`距离，跟绝对定位类型

  - 如果父级都没有定位则以浏览器文档为准
  - 返回的是数字不带单位，并且是只读属性

##### 移动端事件

- 常用触屏事件

  | 触屏touch事件 | 说明                          |
  | ------------- | ----------------------------- |
  | touchstart    | 手指触摸到一个DOM元素时触发   |
  | touchmove     | 手指在一个DOM元素上滑动时触发 |
  | touchend      | 手指从一个DOM元素上移开时触发 |


#### 环境对象-`this`

> 环境对象指的是函数内部特殊的this，它指向一个对象，并且受当前环境的影响

- 弄清楚this的指向可以让代码更简洁

- 函数的调用方式不同，this指代的对象也不同

- 粗略的规则：【谁在调用，this就指向谁】

- 直接调用函数其实就相当于window.函数，所以this指代window

- 对象中的方法和原型对象方法中this指向这个对象

- 间歇函数this指向window

- 事件中this指向事件源

- 箭头函数本身没有this【调用者调用箭头函数this不指向调用者，如果调用者是window则指向window因为window是最大的`BOM`对象】,它只会沿用上一层作用域的this

  ```html
  <button>
      点我
  </button>
  ```

  ```js
  const btn = document.querySelector('button')
  btn.addEventListener('click',function(){
      const fn1 = ()=>console.log(this) // 指向btn
      fn1()
  })
  const fn2 = ()=>console.log(this) // 指向window
  fn2()
  ```


### `BOM`

> `BOM`(Browser Object Model)是浏览器对象模型
>
> ![image-20240531122912521](images/image-20240531122912521.png)

##### `window`对象

> `window`对象是一个全局对象，也可以说是`JavaScript`中的顶级对象，像`document`、`alert()`、`console.log()`这些都是`window`的属性，基本`BOM`的属性和方法都是`window`的，所有通过`var`定义在全局作用域中的变量、函数都会变成`window`对象的属性和方法，`window`对象下的属性和方法调用的时候可以省略`window`

#### `location`对象

> location(地址)它拆分并保存了 URL地址的各个组成部分，它是一个对象

- 常用属性和方法

  | 属性/方法 | 说明                                           |
  | --------- | ---------------------------------------------- |
  | `href`    | 属性，获取完整的URL地址，赋值时用于地址的跳转  |
  | search    | 属性，获取地址中携带的参数，符号`?`后面部分    |
  | hash      | 属性，获取地址中的哈希值，符号`#`后面部分      |
  | reload()  | 方法，用来刷新当前页面，传入true时表示强制刷新 |

#### `navigator`对象

> navigator是对象，该对象下记录了浏览器自身的相关信息

- 常用属性和方法

  通过 `userAgent`检测浏览器的版本及平台

#### `histroy`对象

> history(历史)是对象，主要管理历史记录该对象与浏览器地址栏的操作相对应，如前进、后退等

- 常见方法

  | 方法      | 作用                                         |
  | --------- | -------------------------------------------- |
  | back()    | 后退功能                                     |
  | forward() | 前进功能                                     |
  | go(参数)  | 前进后退功能，正整数表示前进，负整数表示后退 |

#### 本地存储

> 将数据存储在本地浏览器中
>
> - 本地存储能存复杂数据,但是需要将复杂数据进行转换`JSON.stringify()`
> - 取出来的数据能直接使用吗?需要经过` JSON.parse()`转换为`js`数据(对象,数组)

- `localstorage`

  > 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失
  >
  > 以键值对的形式存储，并且存储的是字符串，省略了window

  - 语法

    - 存储数据

      ```js
      localStorage.setItem(key,value)
      ```

    - 读取数据

      ```js
      localStorage.getItem(key)
      ```

    - 删除数据

      ```js
      localStorage.removeItem(key)
      ```

- `sessionstorage`

  > 用法跟localstorage 基本相同,区别是当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除

  - 语法

    - 存储数据

      ```js
      sessionStorage.setItem(key,value)
      ```

    - 读取数据

      ```js
      sessionStorage.getItem(key)
      ```

    - 删除数据

      ```js
      sessionStorage.removeItem(key)
      ```

#### 正则表达式

> 正则表达式(Regular Expression)是一种字符串匹配的模式(规则）

- 正则基本使用

  1. 定义规则

     ```js
     /表达式/
     ```

  2. 使用正则

     ```js
     // 用来查看正则表达式与指定的字符串是否匹配,如果正则表达式与指定的字符串匹配，返回true，否则false
     test() 
     ```

##### 元字符

> 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能，比如，规定用户只能输入英文26个英文字母，换成元字符写法·`/[a-z]/`

###### 边界符

> 定义位置规则，必须用什么开头，用什么结尾

- 正则表达式中的边界符(位置符)用来提示字符所处的位置，主要有两个字符

  | 边界符 | 说明               |
  | ------ | ------------------ |
  | ^      | 表示匹配行首的文本 |
  | $      | 表示匹配行尾的文本 |

  - 如果`^`和`$`在一起，表示必须是精确匹配

###### 量词

> 定义重复次数规则

| 量词  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ？    | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |

- 注意：逗号左右两侧千万不要出现空格

###### 范围

> 表示字符的范围，比如只能是英文字母，或者数字等等，用`[]`表示范围

- 匹配包含的单个字符。例如`[abc]`也就是只有`a|b|c` 这三个单字符返回true，可以理解为多选1
- 连字符`-`。来指定字符范围。`[a-z]`表示`a`到`z`26个英文字母
- 取反符`^`。`[^a-z]`匹配除了小写字母以外的字符

###### 字符类

> 区分各种字符，例如分字母和数字

| 字符类 | 说明                                                       |
| ------ | ---------------------------------------------------------- |
| \d     | 匹配0-9之间的任一数字，相当于[0-9]                         |
| \D     | 匹配所有0-9以外的字符，相当于\[^0-9]                       |
| \w     | 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]           |
| \W     | 除所有字母、数字和下划线以外的字符，相当于\[^A-Za-z0-9_]   |
| \s     | 匹配空格(包括换行符、制表符、空格符等)，相等于[\t\r\n\w\f] |
| \S     | 匹配非空格的字符，相当于\[^ \t\r\n\v\f]                    |

##### 修饰符

> 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等

- 语法

  ```js
  /表达式/修饰符
  ```

  - `i`是单词 ignore 的缩写，正则匹配时字母不区分大小写
  - `g`是单词 global的缩写，匹配所有满足正则表达式的结果

## JavaScript进阶

### 解构赋值

> 解构赋值：可以将数组中的值或对象的属性取出，赋值给其他变量
>
> 解构：其实就是把一个事物的结构进行拆解
>
> 核心：左右两侧结构【`[]`/`{}`】一致

- 数组的解构赋值

  - 语法

    ```js
    // 左右两侧结构相同
    [变量名1[=默认值1],变量名2[=默认值2],...变量名n[=默认值n]] = [数据1,数据2,...数据n]
    // 最外侧的一对[]表示数组括号，里侧的[]表示可选
    ```

    - 右侧数组的值将被赋值给左侧的变量
    - 变量的顺序对应数组值的位置依次进行赋值操作

    ```js
    const [a,b,c] = [1,2,3]
    console.log(a,b,c)
    ```

    - 当数组解构语句【无声明关键字等】独占一行时，在句首之前或者上一行结尾需要有分号

      ```js
      let a =10
      let b = 20;
      [a,b] = [b,a]
      console.log(a,b);
      ```

  - 注意事项

    - 变量多值少，多的值会被赋`undefined`

    - 变量少值多,多的值会被忽略

    - 防止有`undefined`传递值的情况，可以设置默认值

    - 利用剩余参数解决变量少值多的情况

      ```js
      let [a,...b] = [1,2,3,4]
      ```

    - 按需导入，忽略某些值【不需要的空着】

      ```js
      const [a,,b] = [1,2,3]
      ```

    - 多维数组的解构

      ```js
      const [a,b,[c,d]] = [1,2,[3,4]]
      ```

- 对象解构赋值

  > 可以将对象的属性取出，赋值给其他变量

  - 语法

    ```js
    {变量1[:变量1别名][=默认值1],变量2[:变量2别名][=默认值2],...变量n[:变量n别名][=默认值n]} = {属性1:值1,属性2:值2,...属性n:值n}
    ```

    - 右侧对象的属性值将被赋值给左侧的同名变量
    - 变量名如果没有和对象属性名相同的则默认是 `undefined`
    - 解构的变量名不要和外面的变量名冲突否则报错
    - 左右两侧不已顺序为标准，以同名属性取值即可

### 对象深入

#### 创建对象

##### 利用字面量创建对象

```js
const obj = {属性,方法}
```

##### 利用`new Object`创建对象

```js
const obj = new Object({属性,方法}) // new Object是js内置构造函数
```

##### 利用构造函数创建对象

```js
function Person(uname,age){
    this.uname = uname // 实例成员
    this.age = age // 实例成员
}
Person.sex = '女' // 静态成员 通过Person.sex访问
const obj = new Person('lili',18)
```

- 构造函数：是一种特殊的函数，主要用来创建对象(初始化对象)
  - 构造函数在技术上是常规函数
  - 不过有两个约定
    1. 它们的命名以大写字母开头
    2. 通过 `new` 关键字来调用构造函数，可以创建对象
- `new` 实例化执行过程
  1. 创建新空对象
  2. 构造函数`this`指向新对象
  3. 执行构造函数代码
  4. 返回新对象

- 实例成员

  通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员(实例属性和实例方法)

  【实例对象能够访问的属性和方法是实例成员】

  说明：

  1. 为构造函数传入参数，创建结构相同但值不同的对象
  2. 构造函数创建的实例对象彼此独立互不影响

- 静态成员

  构造函数的属性和方法被称为静态成员(静态属性和静态方法)

  【构造函数能够访问的属性和方法是静态成员】

  - 静态方法中的`this`指向构造函数
  - 静态成员只能构造函数来访问

### 内置构造函数

- `Object`

  常用静态方法

  | 静态方法          | 说明                   |
  | ----------------- | ---------------------- |
  | `Object.values()` | 获取对象中所有属性值   |
  | `Object.keys()`   | 获取对象中所有属性(键) |
  | `Object.assign()` | 常用于对象拷贝         |

- `Array`

  常用实例方法

  | 实例方法    | 说明                                                         |
  | ----------- | ------------------------------------------------------------ |
  | `forEach`   | 不返回数组，经常用于查找遍历数组元素                         |
  | `filter`    | 返回新数组，返回的是刷选满足条件的数组元素                   |
  | `map`       | 返回新数组，返回的是处理之后你的数组元素、想要使用返回的新数组 |
  | `reduce`    | 返回的是累计处理的结果，经常用于求和等                       |
  | `join`      | 将数组拼接为字符串，返回拼接后的字符串                       |
  | `find`      | 查找元素，找到则返回元素，否则返回`undefined`                |
  | `every`     | 检测数组元素每一项是否满足某一条件，都满足则返回`true`，否则返回`false` |
  | `some`      | 检测数组中是否有满足某一条件的元素，找到即返回true，未找到即返回false |
  | `concat`    | 合并两个数组，返回生成的新数组                               |
  | `sort`      | 对原数组单元值排序                                           |
  | `splice`    | 删除或替换元素组单元                                         |
  | `reverse`   | 翻转数组                                                     |
  | `findIndex` | 查找某一元素的索引值                                         |

  常见静态方法

  | 静态方法       | 说明                       |
  | -------------- | -------------------------- |
  | `Array.from()` | 返回真数组，不改变原伪数组 |

- `String`

  - 常用实例方法

    | 实例方法                                              | 说明                                                         |
    | ----------------------------------------------------- | ------------------------------------------------------------ |
    | split('分隔符')                                       | 用来将字符串拆分成数组                                       |
    | substring(需要截取的第一个字符的素引[,结束的索引号])) | 用于字符串截取                                               |
    | startsWith(检测字符串[，检测位置系引号])              | 检测是否以某字符开头                                         |
    | includes(搜索的字符串[，检测位置索引号])              | 判断一个字符串是否包含在另一个字符串中，根据情况返回<br/>true 或 false |
    | trim()                                                | 字符串的两端清除空格,返回一个新的字符串，而不修改原始字符串  |
    | toUpperCase()                                         | 用于将字母转换成大写                                         |
    | toLowerCase()                                         | 用于将字母转换成小写                                         |
    | indexOf()                                             | 检测是否包含某字符                                           |
    | endWith()                                             | 检测是否以某字符结尾                                         |
    | replace()                                             | 用于替换字符串，支持正则匹配                                 |
    | match()                                               | 用于查找字符串，支持正则匹配                                 |


### 面向对象编程

> 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。

- 面向对象的特性

  - 封装性
  - 继承性
  - 多态性

- 面向过程和面向对象的对比

  - 面向过程编程

    优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单机片就采用的面向过程编程

    缺点：不灵活、复用性较差

  - 面向对象编程

    优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特点，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

    缺点：性能比面向过程低

#### 构造函数

- 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装
- 把公共的属性和方法抽取封装到构造函数里面来实现数据的共享，这样创建的实例对象可以使用这些属性和方法了
- 构造函数封装时函数(方法)会多次创建，占用内存的问题
- 总结：
  - 构造函数体现了面向对象的封装特性
  - 构造函数实例创建的对象彼此独立、互不影响
  - 构造函数封装时函数(方法)会多次创建，占用内存的问题

#### 原型对象

> JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象
>
> 原型对象可以挂载函数，对象实例化不会多次创建原型对象里面的函数，节约内存
>
> 实例对象可直接访问原型对象中函数
>
> 执行过程:先找实例对象属性或函数，找不到会再找原型对象中属性或函数

- this指向

  构造函数和原型对象中的this 都指向 实例化的对象

- 注意事项
  - 箭头函数不能做构造函数，因为箭头函数里面没有 this
  - 原型对象里面的函数如果需要用到this，也不要用箭头函数

#### `constructor`属性

> 每个原型对象里面都有个constructor属性(constructor 构造函数

- 使用场景

  如果有多个对象的方法，我们可以给原型对象采取对象形式赋值但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。

  ```js
  function Person(name){
      this.uname = name
  }
  
  let person = new Person()
  console.log(Person.prototype);
  Person.prototype.f1 = function(){}
  Person.prototype.f2 = function(){}
  Person.prototype.f3 = function(){}
  console.log(Person.prototype);
  
  Person.prototype = {
      constructor:Person, // 此句写或不写效果不同
      f1(){},
      f2(){},
      f3(){}
  }
  console.log(Person.prototype);
  ```

#### 原型

对象都会有一个属性`_proto_`指向构造函数的 `prototype` 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的方法，就是因为对象有`_proto_`原型的存在

- 注意
  - `_proto_`原先是`JS`非标准属性，但是 `es6` 规范中开始标准化，`[[prototype]]`和_`_proto_`意义相同
  - 尽量不要修改`[[prototype]]`这个属性，对性能影响非常严重的
  - 约定：`prototype`  原型对象 而`_proto_`原型

#### 原型链

`__proto__`属性链状结构称为原型链

作用：原型链为对象成员查找机制提供一个方向，或者说一条路线

- 查找规则

  1. 当访问一个对象成员(属性/方法)时，首先查找这个对象自身有没有该成员(属性/方法)
  2. 如果没有就查找它的原型对象(也就是`__proto__`指向的 `prototype` 原型对象)
  3. 如果还没有就查找原型对象的原型对象(`Object`的原型对象)
  4. 依此类推一直找到 `Object` 为止(`null`)

  ![image-20240604140346744](images/image-20240604140346744.png)

- `instanceof`运算符

  - 语法

    ```js
    实例对象 instanceof 构造函数
    ```

  - 作用

    用来检测`构造函数.prototype`是否存在于实例对象的原型链上

#### 原型继承

JavaScript中大多是借助原型对象实现继承的特性

```js
function Person(){
    this.eye = 2
    this.eat = function(){
        console.log('吃饭');
    }
}
let person = new Person()
function Man(name){
    this.uname = name
}

function Woman(name){
    this.uname = name
}

Man.prototype = person
Man.prototype.constructor = Man
Woman.prototype = person
let man = new Man('张三')
let woman = new Woman('李四')
console.log(man.eye); 
man.eat()
woman.eat()
```

#### 拷贝

##### 浅拷贝

> 把对象拷贝给一个新的对象，开发中我们经常需要复制一个对象

- 方法
  - 对象浅拷贝有`Object.assign()`和展开运算符`{...obj}`
  - 数组浅拷贝有`concat`和展开运算符`[...arr]`
- 注意
  - 如果是基本数据类型拷贝值
  - 如果是引用数据类型拷贝的是地址
  - 如果是单层对象，没问题，如果有多层就有问题，还是会影响原来对象

##### 深拷贝

- 方法
  - `JSON.stringify()`序列化为`JSON `字符串，然后再`JSON.parse()`转回对象格式
    - `JSON`数据不支持`undefinded`和`function`
  - `js`库 `lodash`里面`_.cloneDeep` 内部实现了深拷贝
    - 官网地址:https://www.lodashjs.com/
  - 通过递归实现深拷贝

### 异常处理

#### `throw`抛异常

异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行

- throw 抛出异常信息，程序也会终止执行
- throv后面跟的是错误提示信息
- Error 对象配合 throw 使用，能够设置更详细的错误信息

```js
function sum(x,y){
    if(!x||!y){
        throw new Error('参数不能为空')
    }
    return x+y
}
sum()
```

#### `try/catch`捕获错误信息

- 将预估可能发生错误的代码写在 try 代码段中
- 如果try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息
- finally 不管是否有错误，都会执行

```js
try{
    const div = document.querySelector('.box')
    div.innerHTML = '文本'
}catch(err){
    console.error(err)
}finally{
    console.log('不论是否捕获都会执行');
}
```

#### `debugger`

debugger语句调用调试功能，例如设置断点

### 处理`this`

#### 改变`this`

JavaScript 中允许指定（改变）函数中 this的指向，有3个方法可以动态指定普通函数中 this 的指向

- `call()`

  - 使用`call`方法调用函数，同时指定被调用函数中`this`的指向

  - 语法

    ```js
    函数.call(thisArg,arg1,arg2,...)
    ```

    - `thisArg`：在函数运行时指定的`this`值，为`''`或`null`不改变this指向
    - `arg1`,`arg2`：传递的其他参数
    - 返回值就是函数的返回值，因为它就是调用函数

  - 使用场景

    `Object.prototype.toString.call(data)`，检测数据类型

- `apply()`

  - 使用`apply`方法调用函数，同时指定被调用函数中`this`的值

  - 语法

    ```js
    函数.apply(thisArg,[argsArray])
    ```

    - `thisArg`：在函数运行时指定的`this`值
    - `argsArray`：传递的值，必须包含在数组里面
    - 返回值就是函数的返回值，因为它就是调用函数

  - 使用场景

    `apply`主要跟数组有关系，比如使用`Math.max()`求数组的最大值

- `bind()`

  - bind()方法不会调用函数。但是能改变函数内部 this 指向

  - 语法

    ```js
    函数.bind(thisArg,arg1,arg2,...)
    ```

    - `thisArg`：在函数运行时指定的`this`值，为`''`或`null`不改变this指向
    - `arg1`,`arg2`：传递的其他参数
    - 返回由指定的 this 值和初始化参数改造的 原函数拷贝 (新函数)

  - 使用场景

    当我们只是想改变 this 指向，并且不想调用这个函数时，可以使用 bind，比如改变定时器内部的this指向.

### 性能优化

#### 防抖(`debounce`)

> 单位时间内，频繁触发事件，只执行最后一次

```html
<button>请点击</button>
```

```js
// 防抖构造函数实现
function Debonce(){
    this.timeoutId = null
}
Debonce.prototype.constructor = Debonce
Debonce.prototype.setDebounce = function(fun,time){
    if(this.timeoutId) {
        clearTimeout(this.timeoutId)
    }
    this.timeoutId = setTimeout(()=>{
        fun()
        clearTimeout(this.timeoutId)
        this.timeoutId = null
    },time*1000)
}
let deb = new Debonce()
div.addEventListener('click',function(){
    deb.setDebounce(()=>console.log('点击了'),1)
})
```

```js
// 闭包实现
function debounce(fun,time){
    let timeId = null
    return function(){
        if(timeId) clearTimeout(timeId)
        timeId = detTimeOut(function(){
            fun()
            clearTimeOut(timeId)
            timeId = null
        },time*1000)
    }
}
```

#### 节流 - `throttle`

> 单位时间内，频繁触发事件，只执行一次

```html
<button>请点击</button>
```

```js
// 节流 构造函数实现
function Throttle(){
    this.timeoutId = null
}

Throttle.prototype.constructor = Throttle
Throttle.prototype.setThrottle = function(fun,time){
    if(this.timeoutId) {
        return
    }
    this.timeoutId = setTimeout(()=>{
        fun()
        clearTimeout(this.timeoutId)
        this.timeoutId = null
    },time*1000)
}
let div = document.querySelector('button')
div.addEventListener('click',function(){
    st.setThrottle(()=>console.log('点击了'),1)
})
```

```js
// 闭包实现
function throttle(fun,time){
    let timeId = null
    return function(){
        if(timeId) return
        timeId = setTimeout(function(){
            fun()
            clearTimeout(timeId)
            timeId = null
        },time*1000)
	}
}
```

